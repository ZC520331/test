闭包:有权访问另一个函数作用域中的变量
继承:	原型链继承:引用类型(去掉基本类型)值的原型属性会被所有实例共享
	 	构造函数继承: 方法都在构造函数中定义，每次创建实例都会创建一遍方法
	 	原型式继承:借助原型基于已有的对象创建新的对象 ,其实就是Object.create()得摸你实现 ,将传入的对象作为创建对象的原型
	 	寄生式继承:即创建一个仅用于封装继承过程的函数，该 函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象
	 	寄生组合式继承: 组合继承方式会调用两次父构造函数就会造成属性有两组,一组在实例上,一组在原型上,寄生组合式继承方式可以解决这个问题
作用域: 全局作用域 函数作用域 es6块级作用域
执行上下文的生命周期 : 三个重要属性变量对象 作用域链 this
 * 1.创建阶段
 *      在这个阶段,执行上下文会分别创建变量对象,建立作用域链,以及确定this的指向
 *
 * 2.代码执行阶段
 *      创建完成之后,开始执行代码,在这个时候,会完成变量赋值,函数引用,以及执行其他代码
 *
 * 为什么函数执行上下文中 用活动对象(AO)表示变量对象(AO)
 *      在上下文没有进入之星阶段之前,变量对象中的属性都不能访问
 *      进入执行阶段之后,变量对象转换为活动对象,里面的属性就可以被访问了,然后开始进行执行阶段的操作深浅拷贝
作用域链:
 * 当查找变量时,会先从当前上下文的变量对象中查找,
 * 如果没有找到,就会从父级上下文变量中查找,一直找到全局上下文变量对象,也就是全局对象,
 * 这样由多个执行上下文的变量对象构成的链表叫做作用域链
函数的作用域在函数定义的时候就决定了
函数内部有一个属性[[scope]] 当函数创建的时候，就会保存所有父变量对象到其中

new : 创建一个新对象;
	  将构造函数的作用域赋给新对象(因此 this 就指向了这个新对象);
	  执行构造函数中的代码(为这个新对象添加属性);返回新对象
判断类型 : typeof instanceof(A.__proto === B.prototype) constructor Object.prototype.toString.call('')
基本数据类型存在 栈中

可以修改原型里面的属性吗:基本类型不可以，引用类型可以
cookie怎么跟服务器进行通信，多个tab页面算是同一个session吗？
每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，
需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了
for of for in forEach map的区别
	forEach()方法不会返回执行结果，而是undefined。也就是说，forEach()会修改原来的数组。而map()方法会得到一个新的数组并返回
commonjs:
	用module.exports定义当前模块对外输出的接口（不推荐直接用exports），用require加载模块,
	commonJS用同步的方式加载模块,commonjs输出的是值的拷贝(模块内部的变化就影响不到这个值),commonJS是运行时加载
AMD:	AMD采用异步方式加载模块,用define()定义模块，用require()加载模块
CMD:	它与AMD很类似，不同点在于：AMD 推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行
UMD:	统一浏览器端和非浏览器端的模块化方案
ES6: 	es6模块输出的是值的引用,ES6 模块是编译时输出接口